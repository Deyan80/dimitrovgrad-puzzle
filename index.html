<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Джигсо пъзел — Димитровград</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #f0f0f0; }
        #controls { margin: 20px; }
        #board { border: 2px solid #333; background-color: white; cursor: move; display: block; margin: 20px auto; touch-action: none; }
        #info { margin: 10px; font-size: 18px; }
        button { padding: 10px 15px; margin: 5px; font-size: 16px; }
        #source { display: none; }
    </style>
</head>
<body>
    <h1>Джигсо пъзел — Димитровград</h1>
    
    <div id="controls">
        <label>Трудност:</label><br>
        <button onclick="init(3)">3 x 3 (лесно)</button>
        <button onclick="init(4)">4 x 4 (средно)</button>
        <button onclick="init(6)">6 x 6 (трудно)</button>
        <br><br>
        <button onclick="shuffle()">Разбъркай</button>
        <button onclick="showSolution()">Покажи</button>
    </div>
    
    <canvas id="board" width="600" height="400"></canvas>
    
    <div id="info">
        <span>Време: <span id="time">00:00</span></span> |
        <span>Ходове: <span id="moves">0</span></span>
    </div>
    
    <p>Влачете цветните парчета върху празното място, за да ги преместите.</p>
    
    <img id="source" src="Dimitrovgrad-2018.jpg" alt="Снимка на Димитровград">
    
    <script>
        let canvas = document.getElementById('board');
        let ctx = canvas.getContext('2d');
        let img = document.getElementById('source');
        let size = 3; // default size
        let tileSize;
        let board = [];
        let blankPos = {x: 0, y: 0};
        let moves = 0;
        let timer;
        let timeElapsed = 0;
        let isSolved = false;
        let isLoaded = false;
        let draggedTile = null;

        img.onload = function() {
            console.log('Image loaded successfully');
            isLoaded = true;
            init(size);
        };

        img.onerror = function() {
            console.error('Failed to load image. Check the file name and location.');
            alert('Грешка при зареждане на изображението. Уверете се, че Dimitrovgrad-2018.jpg е в същата папка.');
        };

        function init(newSize) {
            if (!isLoaded) {
                alert('Изображението все още не е заредено. Опитайте отново след секунда.');
                return;
            }
            size = newSize;
            tileSize = Math.min(canvas.width / size, canvas.height / size);
            canvas.width = tileSize * size;
            canvas.height = tileSize * size;
            board = Array.from({length: size * size}, (_, i) => i);
            board[size * size - 1] = -1; // blank tile at end
            blankPos = {x: size - 1, y: size - 1};
            moves = 0;
            timeElapsed = 0;
            isSolved = false;
            document.getElementById('moves').innerText = moves;
            document.getElementById('time').innerText = '00:00';
            if (timer) clearInterval(timer);
            timer = setInterval(updateTime, 1000);
            draw();
            // Remove existing listeners to prevent duplicates
            canvas.removeEventListener('mousedown', startDragging);
            canvas.removeEventListener('mousemove', drag);
            canvas.removeEventListener('mouseup', drop);
            canvas.removeEventListener('mouseleave', cancelDrag);
            canvas.removeEventListener('touchstart', startTouch);
            canvas.removeEventListener('touchmove', touchMove);
            canvas.removeEventListener('touchend', touchEnd);
            // Add mouse and touch event listeners
            canvas.addEventListener('mousedown', startDragging);
            canvas.addEventListener('mousemove', drag);
            canvas.addEventListener('mouseup', drop);
            canvas.addEventListener('mouseleave', cancelDrag);
            canvas.addEventListener('touchstart', startTouch, { passive: false });
            canvas.addEventListener('touchmove', touchMove, { passive: false });
            canvas.addEventListener('touchend', touchEnd, { passive: false });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#ccc';
            for (let i = 0; i <= size; i++) {
                ctx.beginPath();
                ctx.moveTo(i * tileSize, 0);
                ctx.lineTo(i * tileSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * tileSize);
                ctx.lineTo(canvas.width, i * tileSize);
                ctx.stroke();
            }
            for (let i = 0; i < board.length; i++) {
                let row = Math.floor(i / size);
                let col = i % size;
                let x = col * tileSize;
                let y = row * tileSize;
                let tileNum = board[i];
                if (tileNum !== -1) {
                    let srcRow = Math.floor(tileNum / size);
                    let srcCol = tileNum % size;
                    let srcX = srcCol * tileSize;
                    let srcY = srcRow * tileSize;
                    ctx.drawImage(img, srcX, srcY, tileSize, tileSize, x, y, tileSize, tileSize);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x, y, tileSize, tileSize);
                    ctx.strokeStyle = '#333';
                    ctx.strokeRect(x, y, tileSize, tileSize);
                }
            }
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('© 80 г. Димитровград', canvas.width / 2, canvas.height - 30);
            ctx.globalAlpha = 1.0;
        }

        function getTileAt(x, y) {
            let col = Math.floor(x / tileSize);
            let row = Math.floor(y / tileSize);
            if (col >= 0 && col < size && row >= 0 && row < size) {
                return row * size + col;
            }
            return -1;
        }

        function startDragging(event) {
            if (isSolved || !isLoaded) return;
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            let index = getTileAt(x, y);
            if (index >= 0 && board[index] !== -1) {
                draggedTile = index;
                console.log(`Started dragging tile at index: ${draggedTile}`);
            }
        }

        function startTouch(event) {
            if (isSolved || !isLoaded) return;
            event.preventDefault();
            let rect = canvas.getBoundingClientRect();
            let x = event.touches[0].clientX - rect.left;
            let y = event.touches[0].clientY - rect.top;
            let index = getTileAt(x, y);
            if (index >= 0 && board[index] !== -1) {
                draggedTile = index;
                console.log(`Started touching tile at index: ${draggedTile}`);
            }
        }

        function drag(event) {
            if (draggedTile === null) return;
        }

        function touchMove(event) {
            if (draggedTile === null) return;
            event.preventDefault();
        }

        function drop(event) {
            if (draggedTile === null || isSolved || !isLoaded) return;
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            let targetIndex = getTileAt(x, y);
            let blankIndex = blankPos.y * size + blankPos.x;

            console.log(`Dropped at index: ${targetIndex}, blank at: ${blankIndex}`);

            if (targetIndex === blankIndex) {
                [board[draggedTile], board[blankIndex]] = [board[blankIndex], board[draggedTile]];
                blankPos.x = Math.floor(draggedTile % size);
                blankPos.y = Math.floor(draggedTile / size);
                moves++;
                document.getElementById('moves').innerText = moves;
                draw();
                checkSolved();
            }
            draggedTile = null;
        }

        function touchEnd(event) {
            if (draggedTile === null || isSolved || !isLoaded) return;
            event.preventDefault();
            let rect = canvas.getBoundingClientRect();
            let x = event.changedTouches[0].clientX - rect.left;
            let y = event.changedTouches[0].clientY - rect.top;
            let targetIndex = getTileAt(x, y);
            let blankIndex = blankPos.y * size + blankPos.x;

            console.log(`Touch ended at index: ${targetIndex}, blank at: ${blankIndex}`);

            if (targetIndex === blankIndex) {
                [board[draggedTile], board[blankIndex]] = [board[blankIndex], board[draggedTile]];
                blankPos.x = Math.floor(draggedTile % size);
                blankPos.y = Math.floor(draggedTile / size);
                moves++;
                document.getElementById('moves').innerText = moves;
                draw();
                checkSolved();
            }
            draggedTile = null;
        }

        function cancelDrag() {
            draggedTile = null;
        }

        function checkSolved() {
            let solved = board.every((value, index) => value === index || (index === board.length - 1 && value === -1));
            if (solved) {
                isSolved = true;
                draw();
                alert('Поздравления! Решихте пъзела!');
            }
        }

        function shuffle() {
            if (isSolved || !isLoaded) return;
            for (let i = 0; i < 1000; i++) {
                let directions = [
                    {dx: 0, dy: -1}, {dx: 0, dy: 1},
                    {dx: -1, dy: 0}, {dx: 1, dy: 0}
                ];
                let dir = directions[Math.floor(Math.random() * 4)];
                let newX = blankPos.x + dir.dx;
                let newY = blankPos.y + dir.dy;
                if (newX >= 0 && newX < size && newY >= 0 && newY < size) {
                    let newIndex = newY * size + newX;
                    let blankIndex = blankPos.y * size + blankPos.x;
                    [board[newIndex], board[blankIndex]] = [board[blankIndex], board[newIndex]];
                    blankPos.x = newX;
                    blankPos.y = newY;
                }
            }
            moves = 0;
            timeElapsed = 0;
            document.getElementById('moves').innerText = moves;
            document.getElementById('time').innerText = '00:00';
            draw();
        }

        function showSolution() {
            board = Array.from({length: size * size}, (_, i) => i);
            board[size * size - 1] = -1;
            blankPos = {x: size - 1, y: size - 1};
            isSolved = true;
            moves = 0;
            document.getElementById('moves').innerText = moves;
            draw();
        }

        function updateTime() {
            timeElapsed++;
            let minutes = Math.floor(timeElapsed / 60);
            let seconds = timeElapsed % 60;
            document.getElementById('time').innerText = 
                (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        }

        window.onload = function() {
            if (isLoaded) init(3);
        };
    </script>
</body>
</html>
